// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTodo = `-- name: AddTodo :exec
INSERT INTO todo (title, user_id) VALUES ($1, $2)
`

type AddTodoParams struct {
	Title  string
	UserID int32
}

func (q *Queries) AddTodo(ctx context.Context, arg AddTodoParams) error {
	_, err := q.db.Exec(ctx, addTodo, arg.Title, arg.UserID)
	return err
}

const addTodosBatch = `-- name: AddTodosBatch :exec
INSERT INTO todo (title, user_id)
SELECT unnest($1::text[]) AS title, $2 AS user_id
`

type AddTodosBatchParams struct {
	Titles []string
	UserID int32
}

func (q *Queries) AddTodosBatch(ctx context.Context, arg AddTodosBatchParams) error {
	_, err := q.db.Exec(ctx, addTodosBatch, arg.Titles, arg.UserID)
	return err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username
FROM users
WHERE username = $1
`

type GetUserByUsernameRow struct {
	ID       int32
	Username string
}

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (GetUserByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(&i.ID, &i.Username)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, password)
VALUES ($1, $2)
RETURNING id, username
`

type CreateUserParams struct {
	Username string
	Password string
}

type CreateUserRow struct {
	ID       int32
	Username string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.Password)
	var i CreateUserRow
	err := row.Scan(&i.ID, &i.Username)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (user_id, expires)
VALUES ($1, $2)
RETURNING id::text
`

type CreateSessionParams struct {
	UserID  int32
	Expires pgtype.Timestamptz
}

type CreateSessionRow struct {
	ID string
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (CreateSessionRow, error) {
	row := q.db.QueryRow(ctx, createSession, arg.UserID, arg.Expires)
	var i CreateSessionRow
	err := row.Scan(&i.ID)
	return i, err
}

const deleteSession = `-- name: DeleteSession :execrows
DELETE FROM sessions
WHERE id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSession, id)
	return result.RowsAffected(), err
}

const getUserBySession = `-- name: GetUserBySession :one
SELECT u.id, u.username, s.expires
FROM sessions s
JOIN users u ON u.id = s.user_id
WHERE s.id = $1
`

type GetUserBySessionRow struct {
	ID       int32
	Username string
	Expires  pgtype.Timestamptz
}

func (q *Queries) GetUserBySession(ctx context.Context, id string) (GetUserBySessionRow, error) {
	row := q.db.QueryRow(ctx, getUserBySession, id)
	var i GetUserBySessionRow
	err := row.Scan(&i.ID, &i.Username, &i.Expires)
	return i, err
}

const createReport = `-- name: CreateReport :exec
INSERT INTO financial_reports (user_id, filename, content_type, data, status)
VALUES ($1, $2, $3, $4, $5)
`

type CreateReportParams struct {
	UserID      int32
	Filename    string
	ContentType string
	Data        []byte
	Status      string
}

func (q *Queries) CreateReport(ctx context.Context, arg CreateReportParams) error {
	_, err := q.db.Exec(ctx, createReport, arg.UserID, arg.Filename, arg.ContentType, arg.Data, arg.Status)
	return err
}

const listReportsByUser = `-- name: ListReportsByUser :many
SELECT id,
       filename,
       octet_length(data) AS size_bytes,
       status,
       uploaded_at,
       status_description
FROM financial_reports
WHERE user_id = $1
ORDER BY uploaded_at DESC, id DESC
`

type ListReportsByUserRow struct {
	ID                int64
	Filename          string
	SizeBytes         int64
	Status            string
	UploadedAt        pgtype.Timestamptz
	StatusDescription pgtype.Text
}

func (q *Queries) ListReportsByUser(ctx context.Context, userID int32) ([]ListReportsByUserRow, error) {
	rows, err := q.db.Query(ctx, listReportsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListReportsByUserRow
	for rows.Next() {
		var i ListReportsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.SizeBytes,
			&i.Status,
			&i.UploadedAt,
			&i.StatusDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportByID = `-- name: GetReportByID :one
SELECT filename, content_type, data
FROM financial_reports
WHERE id = $1 AND user_id = $2
`

type GetReportByIDParams struct {
	ID     int64
	UserID int32
}

type GetReportByIDRow struct {
	Filename    string
	ContentType string
	Data        []byte
}

func (q *Queries) GetReportByID(ctx context.Context, arg GetReportByIDParams) (GetReportByIDRow, error) {
	row := q.db.QueryRow(ctx, getReportByID, arg.ID, arg.UserID)
	var i GetReportByIDRow
	err := row.Scan(&i.Filename, &i.ContentType, &i.Data)
	return i, err
}

const getExchangeRate = `-- name: GetExchangeRate :one
SELECT rate
FROM exchange_rates
WHERE rate_date = $1
  AND base_currency = $2
  AND target_currency = $3
`

type GetExchangeRateParams struct {
	RateDate       pgtype.Date
	BaseCurrency   string
	TargetCurrency string
}

func (q *Queries) GetExchangeRate(ctx context.Context, arg GetExchangeRateParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getExchangeRate, arg.RateDate, arg.BaseCurrency, arg.TargetCurrency)
	var rate pgtype.Numeric
	err := row.Scan(&rate)
	return rate, err
}

const upsertExchangeRate = `-- name: UpsertExchangeRate :exec
INSERT INTO exchange_rates (rate_date, base_currency, target_currency, rate)
VALUES ($1, $2, $3, $4)
ON CONFLICT (rate_date, base_currency, target_currency)
DO UPDATE SET rate = EXCLUDED.rate
`

type UpsertExchangeRateParams struct {
	RateDate       pgtype.Date
	BaseCurrency   string
	TargetCurrency string
	Rate           pgtype.Numeric
}

func (q *Queries) UpsertExchangeRate(ctx context.Context, arg UpsertExchangeRateParams) error {
	_, err := q.db.Exec(ctx, upsertExchangeRate, arg.RateDate, arg.BaseCurrency, arg.TargetCurrency, arg.Rate)
	return err
}

const listCategoriesByUser = `-- name: ListCategoriesByUser :many
SELECT id, name, color, created_at
FROM categories
WHERE user_id = $1
ORDER BY name
`

type ListCategoriesByUserRow struct {
	ID        int64
	Name      string
	Color     pgtype.Text
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) ListCategoriesByUser(ctx context.Context, userID int32) ([]ListCategoriesByUserRow, error) {
	rows, err := q.db.Query(ctx, listCategoriesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoriesByUserRow
	for rows.Next() {
		var i ListCategoriesByUserRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Color, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (user_id, name, color)
VALUES ($1, $2, $3)
RETURNING id, name, color, created_at
`

type CreateCategoryParams struct {
	UserID int32
	Name   string
	Color  pgtype.Text
}

type CreateCategoryRow struct {
	ID        int64
	Name      string
	Color     pgtype.Text
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (CreateCategoryRow, error) {
	row := q.db.QueryRow(ctx, createCategory, arg.UserID, arg.Name, arg.Color)
	var i CreateCategoryRow
	err := row.Scan(&i.ID, &i.Name, &i.Color, &i.CreatedAt)
	return i, err
}

const updateCategory = `-- name: UpdateCategory :execrows
UPDATE categories
SET name = $1,
    color = $2
WHERE id = $3 AND user_id = $4
`

type UpdateCategoryParams struct {
	Name   string
	Color  pgtype.Text
	ID     int64
	UserID int32
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateCategory, arg.Name, arg.Color, arg.ID, arg.UserID)
	return result.RowsAffected(), err
}

const deleteCategory = `-- name: DeleteCategory :execrows
DELETE FROM categories
WHERE id = $1 AND user_id = $2
`

type DeleteCategoryParams struct {
	ID     int64
	UserID int32
}

func (q *Queries) DeleteCategory(ctx context.Context, arg DeleteCategoryParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteCategory, arg.ID, arg.UserID)
	return result.RowsAffected(), err
}

const categoryExists = `-- name: CategoryExists :one
SELECT EXISTS(
    SELECT 1
    FROM categories
    WHERE id = $1 AND user_id = $2
)
`

type CategoryExistsParams struct {
	ID     int64
	UserID int32
}

func (q *Queries) CategoryExists(ctx context.Context, arg CategoryExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, categoryExists, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listCategoryRulesByUser = `-- name: ListCategoryRulesByUser :many
SELECT id, category_id, description_contains, position, created_at
FROM category_rules
WHERE user_id = $1
ORDER BY position, id
`

type ListCategoryRulesByUserRow struct {
	ID                  int64
	CategoryID          int64
	DescriptionContains string
	Position            int32
	CreatedAt           pgtype.Timestamptz
}

func (q *Queries) ListCategoryRulesByUser(ctx context.Context, userID int32) ([]ListCategoryRulesByUserRow, error) {
	rows, err := q.db.Query(ctx, listCategoryRulesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoryRulesByUserRow
	for rows.Next() {
		var i ListCategoryRulesByUserRow
		if err := rows.Scan(&i.ID, &i.CategoryID, &i.DescriptionContains, &i.Position, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createCategoryRule = `-- name: CreateCategoryRule :one
INSERT INTO category_rules (user_id, category_id, description_contains, position)
VALUES (
    $1,
    $2,
    $3,
    COALESCE((SELECT MAX(position) FROM category_rules WHERE user_id = $1), 0) + 1
)
RETURNING id, category_id, description_contains, position, created_at
`

type CreateCategoryRuleParams struct {
	UserID              int32
	CategoryID          int64
	DescriptionContains string
}

type CreateCategoryRuleRow struct {
	ID                  int64
	CategoryID          int64
	DescriptionContains string
	Position            int32
	CreatedAt           pgtype.Timestamptz
}

func (q *Queries) CreateCategoryRule(ctx context.Context, arg CreateCategoryRuleParams) (CreateCategoryRuleRow, error) {
	row := q.db.QueryRow(ctx, createCategoryRule, arg.UserID, arg.CategoryID, arg.DescriptionContains)
	var i CreateCategoryRuleRow
	err := row.Scan(&i.ID, &i.CategoryID, &i.DescriptionContains, &i.Position, &i.CreatedAt)
	return i, err
}

const updateCategoryRule = `-- name: UpdateCategoryRule :execrows
UPDATE category_rules
SET category_id = $1,
    description_contains = $2
WHERE id = $3 AND user_id = $4
`

type UpdateCategoryRuleParams struct {
	CategoryID          int64
	DescriptionContains string
	ID                  int64
	UserID              int32
}

func (q *Queries) UpdateCategoryRule(ctx context.Context, arg UpdateCategoryRuleParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateCategoryRule, arg.CategoryID, arg.DescriptionContains, arg.ID, arg.UserID)
	return result.RowsAffected(), err
}

const updateCategoryRulePosition = `-- name: UpdateCategoryRulePosition :execrows
UPDATE category_rules
SET position = $1
WHERE id = $2 AND user_id = $3
`

type UpdateCategoryRulePositionParams struct {
	Position int32
	ID       int64
	UserID   int32
}

func (q *Queries) UpdateCategoryRulePosition(ctx context.Context, arg UpdateCategoryRulePositionParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateCategoryRulePosition, arg.Position, arg.ID, arg.UserID)
	return result.RowsAffected(), err
}

const deleteCategoryRule = `-- name: DeleteCategoryRule :execrows
DELETE FROM category_rules
WHERE id = $1 AND user_id = $2
`

type DeleteCategoryRuleParams struct {
	ID     int64
	UserID int32
}

func (q *Queries) DeleteCategoryRule(ctx context.Context, arg DeleteCategoryRuleParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteCategoryRule, arg.ID, arg.UserID)
	return result.RowsAffected(), err
}

const updateTransactionCategory = `-- name: UpdateTransactionCategory :execrows
UPDATE transactions
SET category_id = $1,
    category_source = $2
WHERE id = $3 AND user_id = $4
`

type UpdateTransactionCategoryParams struct {
	CategoryID     pgtype.Int8
	CategorySource pgtype.Text
	ID             int64
	UserID         int32
}

func (q *Queries) UpdateTransactionCategory(ctx context.Context, arg UpdateTransactionCategoryParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateTransactionCategory, arg.CategoryID, arg.CategorySource, arg.ID, arg.UserID)
	return result.RowsAffected(), err
}

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (
    user_id,
    source_file_id,
    source_file_row,
    parser_name,
    posted_date,
    description,
    amount,
    currency,
    transaction_id,
    entry_type,
    source_account_number,
    source_card_number,
    category_id,
    category_source,
    parser_meta
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15
)
`

type CreateTransactionParams struct {
	UserID              int32
	SourceFileID        int64
	SourceFileRow       int32
	ParserName          string
	PostedDate          pgtype.Date
	Description         string
	Amount              pgtype.Numeric
	Currency            string
	TransactionID       pgtype.Text
	EntryType           string
	SourceAccountNumber pgtype.Text
	SourceCardNumber    pgtype.Text
	CategoryID          pgtype.Int8
	CategorySource      pgtype.Text
	ParserMeta          []byte
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.Exec(ctx, createTransaction,
		arg.UserID,
		arg.SourceFileID,
		arg.SourceFileRow,
		arg.ParserName,
		arg.PostedDate,
		arg.Description,
		arg.Amount,
		arg.Currency,
		arg.TransactionID,
		arg.EntryType,
		arg.SourceAccountNumber,
		arg.SourceCardNumber,
		arg.CategoryID,
		arg.CategorySource,
		arg.ParserMeta,
	)
	return err
}

const listTransactionsForRuleApply = `-- name: ListTransactionsForRuleApply :many
SELECT id,
       description,
       category_id,
       category_source
FROM transactions
WHERE user_id = $1
  AND ($2::boolean OR category_source IS DISTINCT FROM 'manual')
`

type ListTransactionsForRuleApplyParams struct {
	UserID     int32
	ApplyToAll bool
}

type ListTransactionsForRuleApplyRow struct {
	ID             int64
	Description    string
	CategoryID     pgtype.Int8
	CategorySource pgtype.Text
}

func (q *Queries) ListTransactionsForRuleApply(ctx context.Context, arg ListTransactionsForRuleApplyParams) ([]ListTransactionsForRuleApplyRow, error) {
	rows, err := q.db.Query(ctx, listTransactionsForRuleApply, arg.UserID, arg.ApplyToAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTransactionsForRuleApplyRow
	for rows.Next() {
		var i ListTransactionsForRuleApplyRow
		if err := rows.Scan(&i.ID, &i.Description, &i.CategoryID, &i.CategorySource); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const summaryTransactions = `-- name: SummaryTransactions :one
SELECT
    COUNT(*) AS count,
    COALESCE(SUM(amount), 0::numeric)::text AS total_amount,
    COALESCE(AVG(amount), 0::numeric)::text AS average_amount,
    COALESCE(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount), 0::numeric)::text AS median_amount
FROM transactions
WHERE user_id = $1
  AND ($2::date IS NULL OR posted_date >= $2)
  AND ($3::date IS NULL OR posted_date <= $3)
  AND ($4::bigint IS NULL OR source_file_id = $4)
  AND ($5::text IS NULL OR entry_type = $5)
  AND ($6::text IS NULL OR source_account_number = $6)
  AND ($7::text IS NULL OR source_card_number = $7)
  AND ($8::text IS NULL OR to_tsvector('simple', description) @@ plainto_tsquery('simple', $8))
  AND ($9::bigint IS NULL OR category_id = $9)
`

type SummaryTransactionsParams struct {
	UserID              int32
	FromDate            pgtype.Date
	ToDate              pgtype.Date
	SourceFileID        pgtype.Int8
	EntryType           pgtype.Text
	SourceAccountNumber pgtype.Text
	SourceCardNumber    pgtype.Text
	SearchText          pgtype.Text
	CategoryID          pgtype.Int8
}

type SummaryTransactionsRow struct {
	Count         int64
	TotalAmount   string
	AverageAmount string
	MedianAmount  string
}

func (q *Queries) SummaryTransactions(ctx context.Context, arg SummaryTransactionsParams) (SummaryTransactionsRow, error) {
	row := q.db.QueryRow(ctx, summaryTransactions,
		arg.UserID,
		arg.FromDate,
		arg.ToDate,
		arg.SourceFileID,
		arg.EntryType,
		arg.SourceAccountNumber,
		arg.SourceCardNumber,
		arg.SearchText,
		arg.CategoryID,
	)
	var i SummaryTransactionsRow
	err := row.Scan(&i.Count, &i.TotalAmount, &i.AverageAmount, &i.MedianAmount)
	return i, err
}

const listTransactionsSummaryRows = `-- name: ListTransactionsSummaryRows :many
SELECT posted_date, amount, currency
FROM transactions
WHERE user_id = $1
  AND ($2::date IS NULL OR posted_date >= $2)
  AND ($3::date IS NULL OR posted_date <= $3)
  AND ($4::bigint IS NULL OR source_file_id = $4)
  AND ($5::text IS NULL OR entry_type = $5)
  AND ($6::text IS NULL OR source_account_number = $6)
  AND ($7::text IS NULL OR source_card_number = $7)
  AND ($8::text IS NULL OR to_tsvector('simple', description) @@ plainto_tsquery('simple', $8))
  AND ($9::bigint IS NULL OR category_id = $9)
`

type ListTransactionsSummaryRowsParams struct {
	UserID              int32
	FromDate            pgtype.Date
	ToDate              pgtype.Date
	SourceFileID        pgtype.Int8
	EntryType           pgtype.Text
	SourceAccountNumber pgtype.Text
	SourceCardNumber    pgtype.Text
	SearchText          pgtype.Text
	CategoryID          pgtype.Int8
}

type ListTransactionsSummaryRowsRow struct {
	PostedDate pgtype.Date
	Amount     pgtype.Numeric
	Currency   string
}

func (q *Queries) ListTransactionsSummaryRows(ctx context.Context, arg ListTransactionsSummaryRowsParams) ([]ListTransactionsSummaryRowsRow, error) {
	rows, err := q.db.Query(ctx, listTransactionsSummaryRows,
		arg.UserID,
		arg.FromDate,
		arg.ToDate,
		arg.SourceFileID,
		arg.EntryType,
		arg.SourceAccountNumber,
		arg.SourceCardNumber,
		arg.SearchText,
		arg.CategoryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTransactionsSummaryRowsRow
	for rows.Next() {
		var i ListTransactionsSummaryRowsRow
		if err := rows.Scan(
			&i.PostedDate,
			&i.Amount,
			&i.Currency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteReportByID = `-- name: DeleteReportByID :exec
DELETE FROM financial_reports
WHERE id = $1 AND user_id = $2
`

type DeleteReportByIDParams struct {
	ID     int64
	UserID int32
}

func (q *Queries) DeleteReportByID(ctx context.Context, arg DeleteReportByIDParams) error {
	_, err := q.db.Exec(ctx, deleteReportByID, arg.ID, arg.UserID)
	return err
}

const deleteTransactionsBySource = `-- name: DeleteTransactionsBySource :exec
DELETE FROM transactions
WHERE source_file_id = $1 AND user_id = $2
`

type DeleteTransactionsBySourceParams struct {
	SourceFileID int64
	UserID       int32
}

func (q *Queries) DeleteTransactionsBySource(ctx context.Context, arg DeleteTransactionsBySourceParams) error {
	_, err := q.db.Exec(ctx, deleteTransactionsBySource, arg.SourceFileID, arg.UserID)
	return err
}

const listPendingReports = `-- name: ListPendingReports :many
SELECT id, user_id, filename, data
FROM financial_reports
WHERE status = 'pending'
ORDER BY uploaded_at ASC, id ASC
`

type ListPendingReportsRow struct {
	ID       int64
	UserID   int32
	Filename string
	Data     []byte
}

func (q *Queries) ListPendingReports(ctx context.Context) ([]ListPendingReportsRow, error) {
	rows, err := q.db.Query(ctx, listPendingReports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPendingReportsRow
	for rows.Next() {
		var i ListPendingReportsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Filename,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodosByUser = `-- name: ListTodosByUser :many
SELECT id, title FROM todo WHERE user_id = $1 ORDER BY id
`

type ListTodosByUserRow struct {
	ID    int32
	Title string
}

func (q *Queries) ListTodosByUser(ctx context.Context, userID int32) ([]ListTodosByUserRow, error) {
	rows, err := q.db.Query(ctx, listTodosByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTodosByUserRow
	for rows.Next() {
		var i ListTodosByUserRow
		if err := rows.Scan(&i.ID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT id,
       source_file_id,
       source_file_row,
       parser_name,
       posted_date,
       description,
       amount,
       currency,
       transaction_id,
       entry_type,
       source_account_number,
       source_card_number,
       category_id,
       parser_meta,
       created_at
FROM transactions
WHERE user_id = $1
  AND ($2::date IS NULL OR posted_date >= $2)
  AND ($3::date IS NULL OR posted_date <= $3)
  AND ($4::bigint IS NULL OR source_file_id = $4)
  AND ($5::text IS NULL OR entry_type = $5)
  AND ($6::text IS NULL OR source_account_number = $6)
  AND ($7::text IS NULL OR source_card_number = $7)
  AND ($8::text IS NULL OR to_tsvector('simple', description) @@ plainto_tsquery('simple', $8))
  AND ($9::bigint IS NULL OR category_id = $9)
ORDER BY posted_date DESC, id DESC
LIMIT $11
OFFSET $10
`

type ListTransactionsParams struct {
	UserID              int32
	FromDate            pgtype.Date
	ToDate              pgtype.Date
	SourceFileID        pgtype.Int8
	EntryType           pgtype.Text
	SourceAccountNumber pgtype.Text
	SourceCardNumber    pgtype.Text
	SearchText          pgtype.Text
	CategoryID          pgtype.Int8
	OffsetCount         int32
	LimitCount          int32
}

type ListTransactionsRow struct {
	ID                  int64
	SourceFileID        int64
	SourceFileRow       int32
	ParserName          string
	PostedDate          pgtype.Date
	Description         string
	Amount              pgtype.Numeric
	Currency            string
	TransactionID       pgtype.Text
	EntryType           string
	SourceAccountNumber pgtype.Text
	SourceCardNumber    pgtype.Text
	CategoryID          pgtype.Int8
	ParserMeta          []byte
	CreatedAt           pgtype.Timestamptz
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]ListTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listTransactions,
		arg.UserID,
		arg.FromDate,
		arg.ToDate,
		arg.SourceFileID,
		arg.EntryType,
		arg.SourceAccountNumber,
		arg.SourceCardNumber,
		arg.SearchText,
		arg.CategoryID,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTransactionsRow
	for rows.Next() {
		var i ListTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceFileID,
			&i.SourceFileRow,
			&i.ParserName,
			&i.PostedDate,
			&i.Description,
			&i.Amount,
			&i.Currency,
			&i.TransactionID,
			&i.EntryType,
			&i.SourceAccountNumber,
			&i.SourceCardNumber,
			&i.CategoryID,
			&i.ParserMeta,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTodo = `-- name: RemoveTodo :exec
DELETE FROM todo WHERE id = $1 AND user_id = $2
`

type RemoveTodoParams struct {
	ID     int32
	UserID int32
}

func (q *Queries) RemoveTodo(ctx context.Context, arg RemoveTodoParams) error {
	_, err := q.db.Exec(ctx, removeTodo, arg.ID, arg.UserID)
	return err
}

const updateReportStatus = `-- name: UpdateReportStatus :exec
UPDATE financial_reports
SET status = $1
WHERE id = $2 AND user_id = $3
`

type UpdateReportStatusParams struct {
	Status string
	ID     int64
	UserID int32
}

func (q *Queries) UpdateReportStatus(ctx context.Context, arg UpdateReportStatusParams) error {
	_, err := q.db.Exec(ctx, updateReportStatus, arg.Status, arg.ID, arg.UserID)
	return err
}

const updateReportStatusWithError = `-- name: UpdateReportStatusWithError :exec
UPDATE financial_reports
SET status = $1,
    status_description = $2
WHERE id = $3 AND user_id = $4
`

type UpdateReportStatusWithErrorParams struct {
	Status            string
	StatusDescription pgtype.Text
	ID                int64
	UserID            int32
}

func (q *Queries) UpdateReportStatusWithError(ctx context.Context, arg UpdateReportStatusWithErrorParams) error {
	_, err := q.db.Exec(ctx, updateReportStatusWithError,
		arg.Status,
		arg.StatusDescription,
		arg.ID,
		arg.UserID,
	)
	return err
}
